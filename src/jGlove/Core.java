package jGlove;

import jGlove.gesture.Gesture;
import jGlove.midi.IMidiMessable;
import jGlove.midi.MidiReceiver;
import jGlove.mouse.MouseSensor;
import jGlove.sensor.Sensor;
import jGlove.shared.IPropertyChangeListener;
import jGlove.shared.ISource;
import jGlove.shared.PropertyChangeEvent;
import jGlove.shared.PropertyChangeSupport;

import java.io.EOFException;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.List;

import javax.sound.midi.MidiUnavailableException;
import javax.sound.midi.ShortMessage;
import javax.sound.midi.MidiDevice.Info;

import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.swt.widgets.Display;

/**
 * The Core is responsible for loading and saving data between
 * sessions that is not directly associated with the workbench.
 * <p>
 * This data includes number, types, names and calibration of
 * sensors and gestures. If a sensor or gesture is configured
 * to send a midi message, this configuration is saved as well.
 * <p>
 * The methods <code>load() and <code>save() are run on startup
 * and shutdown.
 * By serializing and deserializing the necessary fields, the
 * mentioned data is persistant.
 * <p>
 * The class follows the singleton pattern and the instance
 * can be public accessed via <code>getDefault()</code> .
 * The private constructor loads the default or user defined 
 * for performance setting and MIDI device. By adding a 
 * <code>IPropertyChangeListener</code>  to the 
 * <code>IPreferenceStore</code> , those settings are updated 
 * when changed by the user.
 * <p>
 * The more important startup code is performed in 
 * the <code>startup()</code> method. Its equivalent on shutdown
 * is <code>shutdown()</code>.
 * <p>
 * There are several fields that store sensors, gestures,
 * mousesensors, actives and midi messables. <code>Sensor</code>
 * objects are generated on startup.
 * <p>
 * <code>Gesture</code> objects are generated by the user 
 * via <code>GestureWizard</code> and can be registered
 * with the <code>addGesture()</code> method.
 * <p>
 * <code>MouseSensor</code> objects are created from
 * the toolbar button in the Mouse Pad (<code>MouseView</code>).
 * <p>
 * A <code>Source</code> object (at this moment: sensor, Gesture
 * or mouseSensor) can be active or inactive. Every active Source
 * object is displayed in the not-closeable monitor view.
 * When adding or removing an object from the active list, a
 * <code>PropertyChangeEvent</code> is fired to every listener.
 * <p>
 * Similar to the active state, a <code>Source</code> object
 * can have a midi message. Those can be registered with 
 * <code>addMidi()</code> and retrieved with <code>getMidi()</code>.
 * <p>
 * After connecting to the GloveBox, loading and initializing
 * objects, the <code>Engine</code> is started. This thread
 * updates all sensor objects, calculates the current state
 * of all gestures and checks for midi messages.
 * <p>
 * For better performance, the result of the methods
 * <code>getGestures()</code> and <code>getMidi()</code>
 * (both are very often invoked by the <code>Engine</code>)
 * are cached inside the getters. To delete the caches when
 * necessary, IPropertyChangeListeners are registered in the
 * startup method.
 * 
 * @see jGlove.shared.Source
 * @see jGlove.sensor.Sensor
 * @see jGlove.sensor.SensorView
 * @see jGlove.gesture.Gesture
 * @see jGlove.gesture.GestureView
 * @see jGlove.mouse.MouseSensor
 * @see jGlove.mouse.MouseView
 * @see jGlove.monitor.MonitorView
 */
// TODO cleanup inline docs, way too much text
// TODO File -> Load / Save to choose a persistant file instead of a static file
public class Core {
	
	/**
	 * The only instance if an Engine, is started on startup()
	 * and stopped on shutdown().
	 */
	private Engine coreEngine;
	
	/**
	 * This interval is used by the Engine when it sleeps. Higher
	 * values result in lower cpu usage.
	 */
	private int coreInterval;

	/**
	 * This file is used to store all serialized data. Subject to change.
	 */
	private static String persistantfilename = "/resource/persistent.dat"; //$NON-NLS-1$
	
	/**
	 * This switch stores wheather to send midi messages or not.
	 * The switch is located in the MonitorView.
	 * @see #setGlobalMidiOnOff(boolean)
	 * @see #getGlobalMidiOnOff()
	 */
	private boolean globalMidiOnOff;
	
	/**
	 * On first startup, a default midi device is connected and 
	 * stored in this field. The user can change the device
	 * by choosing another via the preferencedialog.
	 * @see #getMidiDevice()
	 * @see #closeMidiDevice() 
	 */
	private MidiReceiver midiDevice;
	
	/**
	 * This array of Sensor object is created on startup and
	 * should not be changed. When the GloveBox is connected, 
	 * the number of Sensor objects depends on the number of
	 * available channels. Otherwise, an array of 8 default
	 * sensors is created.
	 * @see #getSensors() 
	 */
	private Sensor[] sensors;
	
	/**
	 * Created gesturesare stored in this List.
	 * @see #addGesture(Gesture)
	 * @see #removeGesture(Gesture)
	 * @see #getGestures()  
	 */
	private List gestures = new ArrayList(1);
	
	/**
	 * When the available gestures are retrieved via
	 * getGestures(), the result is cached inside this
	 * field for better performance.
	 */
	// FIXME drop it, its just a copy of the ArrayList above
	private Gesture[] gestureCache;
    
	/**
	 * MouseSensor object are either created in the MouseView
	 * or loaded on startup.
	 * @see jGlove.mouse.MouseView
	 * @see #setMouseSensors(MouseSensor[])
	 * @see #getMouseSensors()
	 */
    private MouseSensor[] mouseSensors;
	
    /**
     * This listener is invoked whenever the a check to send
     * a midi message returns true. Its responsibilty is to
     * send the midi message to a receiver and give feedback
     * about this message.
     * @see IMidiMessable#checkMidiMessage()
     * @see jGlove.shared.Source#checkMidiMessage()
     */
	private IPropertyChangeListener midiListener = new IPropertyChangeListener() {
		public void propertyChange(PropertyChangeEvent event) {
			ShortMessage sm = (ShortMessage)event.getNewValue();
			if(sm != null) {
				if(getMidiDevice() != null) {
					getMidiDevice().send(sm);
				}
                // TODO more useful output!
				// FIXME use logging
				System.out.println(((ISource) event.getSource()).getMidiMessage().getInfoMidiMessage());
			}
		}
	};
	
	/**
	 * This List contains all IMidiMessable objects that have
	 * a midi message and need to be checked if this 
	 * message should be sent.
	 */
	private List midiList = new ArrayList(3);
	
	/**
	 * When the available IMidiMessables are retrieved via
	 * getMidi(), the result is cached inside this
	 * field for better performance.
	 */
	// FIXME drop it, just a copy of the above ArrayList
	private IMidiMessable[] midiCache;
	
	/**
	 * This List contains all active ISource objects, used
	 * by the MonitorView and GraphicalMonitorView to display
	 * those.
	 */
	private List activeList = new ArrayList();
	
	/**
	 * When the available ISources are retrieved via
	 * getActives(), the result is cached inside this
	 * field for better performance.
	 */
	// FIXME drop it, just a copy of the above ArrayList
	private ISource[] activeCache;
	
	/**
	 * This PropertyChangeSupport manages all IPropertyChangeListeners
	 * that listen on the various fields.
	 */
	private PropertyChangeSupport propertyChangeSupport = new PropertyChangeSupport(this);
	
	/**
	 * There can by only one connection at a time to the GloveBox.
	 * The only instance that may be created is stored here.
	 */
	private IGloveBox gb;
	
	/**
	 * The singleton instance of this class.
	 */
	private static Core instance;
	
	/**
	 * Default and user values for some options (i.e. midi device, 
	 * performance settings) are stored in this IPreferenceStore.
	 */
	private IPreferenceStore store;
	
	/**
	 * Default constructor, does nothing. Instead, all work is done
	 * within the startup() method.
	 */
	private Core() {
	}
	
	/**
	 * only one Core object may exist, it is lazily
	 * created (on the first request)
	 * @return the only Core object
	 */
	public static Core getDefault() {
		if(instance == null) {
			instance = new Core();
		}
		return instance;
	}
	
	/**
	 * This method should be invoked only one per session.
	 * It does the following:
	 * <p>
	 * 1. Load performance setting (coreInterval) and MIDI-Device,
	 * try to connect to the MIDI-Device
	 * 2. Connect to GloveBox<br> 
	 * 3. Load serialized data<br>
	 * 4. Perform necessary initialization (on first startup or when
	 * loading failed)<br>
	 * 5. Add propertyChangeListener<br>
	 * 6. Start the Engine<br>
	 */
	public void startup() {
		store = JGlovePlugin.getDefault().getPreferenceStore();
		doSetCoreInterval(store);
		doSetMidiDevice(store);
		store.addPropertyChangeListener(new org.eclipse.jface.util.IPropertyChangeListener() {
			public void propertyChange(org.eclipse.jface.util.PropertyChangeEvent event) {
				if(event.getProperty().equals(IJGloveConstants.P_CORE_PERFORMANCE)) {
					doSetCoreInterval(store);
				}
				if(event.getProperty().equals(IJGloveConstants.P_MIDI_DEVICE)) {
					doSetMidiDevice(store);
				}
			}
		});
		
		
    	try {
    		// TODO make configurable or just try both
			gb = new J2DXXGloveBox();
    		// gb = new WLANGloveBox();
		} catch (Exception e) {
			e.printStackTrace();
			JGlovePlugin.log(e);
			MessageDialog.openWarning(Display.getCurrent().getActiveShell(), Messages.Core_error_glovebox_title, e.getMessage());
		}

		load();
		
		if(sensors == null || sensors.length == 0) {
			int[] channels = {0, 10, 50, 100, 200, 500, 1023, 1024};
            if(gb != null) {
                channels = gb.getAllChannels();
            }
			if(channels != null) {
			    sensors = new Sensor[channels.length];
			    for(int i=0; i<channels.length; i++) {
			        sensors[i] = new Sensor(i, channels[i]);
			    }                
            }
		}
		
        propertyChangeSupport.addPropertyChangeListener("midi", new IPropertyChangeListener() { //$NON-NLS-1$
			public void propertyChange(PropertyChangeEvent event) {
				midiCache = null;
			}
		});
        propertyChangeSupport.addPropertyChangeListener("active", new IPropertyChangeListener() { //$NON-NLS-1$
			public void propertyChange(PropertyChangeEvent event) {
				activeCache = null;
			}
		});
        propertyChangeSupport.addPropertyChangeListener("gesture", new IPropertyChangeListener() { //$NON-NLS-1$
			public void propertyChange(PropertyChangeEvent event) {
				gestureCache = null;
			}
		});
		
		coreEngine = new Engine();
		coreEngine.start();
	}
	
	/**
	 * This method should be invoked only one per session.
	 * It does the following:
	 * <p>
	 * 1. Close the MIDI-Device<br>
	 * 2. Close the GloveBox<br>
	 * 3. Stop the Engine<br>
	 * 4. Save data by serializing
	 */
	public void shutdown() {
		closeMidiDevice();
		
		if(gb != null) {
			gb.close();
		}
		
        if(coreEngine != null) {
            coreEngine.interrupt();            
        }
        save();
        
	}
	
	/**
	 * Load data like sensors, gestures, mouseSensors, 
	 * midimessables and actives by deserializing. 
	 */
	private void load() {
		ObjectInputStream objectInputStream = null;
		try {
			FileInputStream fis = new FileInputStream(JGlovePlugin.getFile(persistantfilename));
			if (fis == null) {
				return;
			}
			objectInputStream = new ObjectInputStream(fis);
			sensors = (Sensor[]) objectInputStream.readObject();
			gestures = (List) objectInputStream.readObject();
			midiList = (List) objectInputStream.readObject();
			activeList = (List) objectInputStream.readObject();
            mouseSensors = (MouseSensor[]) objectInputStream.readObject();
        } catch (EOFException e) {
            // do nothing, file was empty, will only happen once
		} catch (IOException e) {
			e.printStackTrace();
			JGlovePlugin.log(e);
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
			JGlovePlugin.log(e);
		} finally {
			if(objectInputStream != null) {
				try {
					objectInputStream.close();
				} catch (IOException e) {
					e.printStackTrace();
					JGlovePlugin.log(e);
				}
			}
		}
	}
	
	/**
	 * Save data like sensors, gestures, mouseSensors, 
	 * midimessables and actives by serializing.
	 */
	private void save() {
		// TODO replace serialization with plaintext persistence
		ObjectOutputStream objectOutputStream = null;
		try {
			FileOutputStream fos = new FileOutputStream(JGlovePlugin.getFile(persistantfilename));
			if(fos == null) {
				return;
			}
			objectOutputStream = new ObjectOutputStream(fos);
			objectOutputStream.writeObject(sensors);
			objectOutputStream.writeObject(gestures);
			objectOutputStream.writeObject(midiList);
	        /*
	         * remove mouseSensors from activeList if necessary,
	         * workaround to prevent having "dead" mouseSensors
	         * 
	         * just remove this workaround to see what happens
	         */ 
	        if(mouseSensors != null) {
	            for (int i = 0; i < mouseSensors.length; i++) {
	                activeList.remove(mouseSensors[i]);
	            }
	        }
			objectOutputStream.writeObject(activeList);
	        objectOutputStream.writeObject(mouseSensors);
		} catch (IOException e) {
			e.printStackTrace();
			JGlovePlugin.log(e);
		} finally {
			if(objectOutputStream != null) {
				try {
					objectOutputStream.close();
				} catch (IOException e) {
					e.printStackTrace();
					JGlovePlugin.log(e);
				}				
			}
		}
	}
	
	/**
	 * Load the main performance setting for the engine,
	 * the sleep interval, from the given IPrefereanceStore
	 * and set the field.
	 * @param store The instance of the Plug-In's store
	 */
	private void doSetCoreInterval(IPreferenceStore store) {
		String mode = store.getString(IJGloveConstants.P_CORE_PERFORMANCE);
		coreInterval = Integer.valueOf(mode).intValue();
	}
	
	/**
	 * Load the MIDI-Device setting from the given IPrefereanceStore
	 * and set the field.
	 * @param store The instance of the Plug-In's store
	 */
	private void doSetMidiDevice(IPreferenceStore store) {
		String mode = store.getString(IJGloveConstants.P_MIDI_DEVICE);
		int midiDeviceNumber = Integer.valueOf(mode).intValue();
		Info[] infos = MidiReceiver.getDevices();
		// FIXME better check plz
		if (midiDeviceNumber < infos.length ) {
			try {
				midiDevice = new MidiReceiver(infos[midiDeviceNumber]);
			} catch (MidiUnavailableException e) {
				e.printStackTrace();
				JGlovePlugin.log(e);
				MessageDialog.openWarning(Display.getCurrent().getActiveShell(), Messages.Core_error_midiconnect, Messages.Core_error_midiunavailable);
			}
		}
	}
	
	/**
	 * Returns the PropertyChangeSupport of this class.
	 * Should be used by clients who wish to add themselves
	 * as a IPropertyChangeListener.
	 * @return the PropertyChangeSupport of this class
	 */
	public PropertyChangeSupport getPropertyChangeSupport() {
		return propertyChangeSupport;
	}
	
	/**
	 * Add a source object as being active. Any "active" listeners
	 * are informed by a PropertyChangeEvent
	 * @param source the source object that got activated
	 */
	public void addActive(ISource source) {
		addActive(source, false);
	}
	
	/**
	 * Add a source object as being active. If silent is true,
	 * "active" listeners are informed, if silent is false,
	 * the method does the same as addActive(ISource).
	 * @param source the source object that got activated
	 * @param silent if false, listeners are informed
	 */
	public void addActive(ISource source, boolean silent) {
		activeList.add(source);
		if(!silent) {
			propertyChangeSupport.firePropertyChange("active", source); //$NON-NLS-1$
		}
	}
	
	/**
	 * Removes a source object from the List of actives.
	 * Listeners are informed.
	 * @param source the deactivated source
	 */
	public void removeActive(ISource source) {
		removeActive(source, false);
	}
	
	/**
	 * Removes a source object from the List of actives.
	 * Listeneres are informed, if silent is false, otherwise,
	 * listeneres are not informed.
	 * @param source the source object that got deactivated
	 * @param silent if false, listeners are informed
	 */
	public void removeActive(ISource source, boolean silent) {
		activeList.remove(source);
		if(!silent) {
			propertyChangeSupport.firePropertyChange("active", source); //$NON-NLS-1$
		}
	}
	
	/**
	 * Adds this array of ISource objects as active
	 * and fires a "active" PropertyChangeEvent after
	 * all have been added.
	 * @param sources the objects that got activated
	 */
	public void addActives(ISource[] sources) {
		for (int i = 0; i < sources.length; i++) {
			activeList.add(sources[i]);
		}
		propertyChangeSupport.firePropertyChange("active", null); //$NON-NLS-1$
	}
	
	/**
	 * Removes this array of ISource objects 
	 * and fires a "active" PropertyChangeEvent after
	 * all have been removed.
	 * @param sources the objects that got deactivated
	 */
	public void removeActives(ISource[] sources) {
		for (int i = 0; i < sources.length; i++) {
			activeList.remove(sources[i]);
		}
		propertyChangeSupport.firePropertyChange("active", null); //$NON-NLS-1$
	}
	
	/**
	 * Returns all active ISource objects. The result
	 * is cached.
	 * @return all active ISource objects as an Array
	 */
	public ISource[] getActives() {
		if(activeCache == null) {
			activeCache = (ISource[])activeList.toArray(new ISource[activeList.size()]);
		}
		return activeCache;
	}
	
	/**
	 * Adds the given IMidiMessable to the List and fires a
	 * "midi"-PropertyChangeEvent. If a new midimessage
	 * is created and associated with a ISource, it should be
	 * added with method to check if the midimessage needs to
	 * be sent.
	 * @param source the source to be added 
	 */
	public void addMidi(IMidiMessable source) {
		midiList.add(source);
		propertyChangeSupport.firePropertyChange("midi", source); //$NON-NLS-1$
	}
	
	/**
	 * Removes the given IMidiMessable from the List and fires a
	 * "midi"-PropertyChangeEvent.
	 * @param source the source to be removed 
	 */
	public void removeMidi(IMidiMessable source) {
		midiList.remove(source);
		propertyChangeSupport.firePropertyChange("midi", source); //$NON-NLS-1$
	}
	
	/**
	 * Returns all registered IMidiMessables. The result is cached
	 * for better performance. Usualy, this method is invoked
	 * by the engine.
	 * @return all available IMidiMessables
	 */
	public IMidiMessable[] getMidi() {
		if(midiCache == null) {
			midiCache = (IMidiMessable[])midiList.toArray(new IMidiMessable[midiList.size()]);
		}
		return midiCache;
	}
	
	/**
	 * Returns the listener that is responsible for sending
	 * midimessages.
	 * @return the MIDI-IPropertyChangeListener
	 */
	public IPropertyChangeListener getMidiListener() {
		return midiListener;
	}
    
	
	/**
	 * Returns true, if midimessages are to be sent, otherwise
	 * false
	 * @return true: send midimessages, false: do nothing 
	 */
	public boolean getGlobalMidiOnOff() {
		return globalMidiOnOff;
	}
	
	/**
	 * Sets the sending off midimessages on or off
	 * @param globalMidiOnOff true, if midimessages should be send
	 */
	public void setGlobalMidiOnOff(boolean globalMidiOnOff) {
		this.globalMidiOnOff = globalMidiOnOff;
	}
	
	/**
	 * Returns the currently connected MidiDevice or null,
	 * if it was not possible to connect to the device
	 * @return the connected MidiDevice
	 */
	public MidiReceiver getMidiDevice() {
		return midiDevice;
	}
	
	/**
	 * Closes the connected MidiDevice
	 */
	public void closeMidiDevice() {
		if(midiDevice != null) {
			midiDevice.close();
		}
	}
	
	/**
	 * Adds the given gesture and fires a "gesture"
	 * PropertyChangeEvent. The gesture will be calculated
	 * in every Engine loop.
	 * @param gesture the gesture to add
	 */
	public void addGesture(Gesture gesture) {
		gestures.add(gesture);
		propertyChangeSupport.firePropertyChange("gesture", gesture); //$NON-NLS-1$
	}
	
	/**
	 * Returns all available Gesture objects, the result is
	 * cached.
	 * @return all available Gesture objects
	 */
	public Gesture[] getGestures() {
		if(gestureCache == null) {
			gestureCache = (Gesture[])gestures.toArray(new Gesture[gestures.size()]);
		}
		return gestureCache;
	}
	
	/**
	 * Removes the given gesture, it wont be calculated
	 * anymore, and sends a "gesture" PropertyChangeEvent
	 * @param gesture the gesture to remove
	 */
    public void removeGesture(Gesture gesture) {
        gestures.remove(gesture);
        if(gesture.getActive()) {
        	removeActive(gesture);
        }
        propertyChangeSupport.firePropertyChange("gesture", gesture); //$NON-NLS-1$
    }
    
    /**
     * Sets the given array of MouseSensors. They are stored
     * on shutdown and restored on startup.
     * @param mouseSensors the MouseSensor to store
     */
    public void setMouseSensors(MouseSensor[] mouseSensors) {
        this.mouseSensors = mouseSensors;
    }
    
    /**
     * Returns the stored MouseSensors or null, if there are none.
     * @return any available MouseSensors or null
     */
    public MouseSensor[] getMouseSensors() {
        return mouseSensors;
    }
    
    /**
     * Returns the available Sensor objects. Those are either
     * generated with GloveBox data, generated with default values
     * or restored on startup().
     * @return any available Sensor objects
     */
	public Sensor[] getSensors() {
		return sensors;
	}

    /**
     * This thread is responsible for:<br>
     *  - retrieving data from the connected GloveBox
     *    and update associated sensors<br>
     *  - recalculate all gestures<br>
     *  - check for midi messages<br>
     *  <p>
     *  If the need for other components to get updated arises,
     *  it would be a good idea to add those updates here.
     *  <p>
     *  This Thread is intended to run only once.
     *  @see #updateSensors()
     *  @see #checkGestures()
     *  @see #checkMidiMessages()
     */
	// TODO promote to top-level, implement Runnable instead of extending Thread
	private class Engine extends Thread {

		/**
		 * This cache stores the values that were retrieved from
		 * the GloveBox to see, if they changed.
		 */
		// TODO could be retrieved from sensors?
		private int[] channelCache = null;
		
		/**
		 * default constructor, sets a name for the thread
		 * to identify it when debugging
		 */
		protected Engine() {
			setName("Core Engine"); //$NON-NLS-1$
		}
		
		/**
		 * This method is invoked when the threads starts.
		 * <p>
		 * As long as the application is running, nothing
		 * should stop this from running.
		 * @see #updateSensors()
		 * @see #checkGestures()
		 * @see #checkMidiMessages()
		 */
		public void run() {
			while(!isInterrupted()) {
				try {
					sleep(coreInterval);
				} catch(InterruptedException e) {
					interrupt();
					break;
				}
                updateSensors();
                checkGestures();
                checkMidiMessages();
			}
		}
        
		/**
		 * This method retrieves data from the connected
		 * GloveBox (if available), compares if values
		 * have changed and updates the sensor if necessary.
		 * <p>
		 * By passing comparation to the getMoreRunsNeeded()
		 * methord of the Sensor object, it is possible to
		 * update a Sensor even if no value has changed.
		 * <p>
		 * This is a workaround to allow "active" Filters.
		 * <p>
		 * If there is no GloveBox data available, the sensors
		 * are updated with there own value, this allows the
		 * mentioned "active" Filters to run even when there is
		 * no GloveBox data.
		 * @see jGlove.filter.SmoothingFilter
		 * @see jGlove.filter.ModulationFilter
		 */
        private void updateSensors() {
            int[] channels = null;
            if(gb != null) {
            	channels = gb.getAllChannels();
            }
            if(channels != null) {
                for(int i=0; i<sensors.length; i++) {
                    if(channelCache != null && sensors[i].getMoreRunsNeeded(channels[i] != channelCache[i]) == 0) {
                    	continue;
                    }
                    sensors[i].setValueRaw(channels[sensors[i].getIndex()]);
                }
                channelCache = channels;                
            } else {
                for (int i = 0; i < sensors.length; i++) {
                    sensors[i].setValueRaw(sensors[i].getValue());
                }
            }
        }
        
        /**
         * This method simply retrieves all available
         * Gesture objects and invokes the calculate()
         * method.
         * <p>
         * Checks if the value has changed and if any
         * GUI components need to be updated are inside
         * the calculate() method.
         */
        private void checkGestures() {
            Gesture[] gestures = getGestures();
            if(gestures != null) {
                for(int i=0; i<gestures.length; i++) {
                    gestures[i].calculate();
                }
            }
        }
        
        /**
         * When invoked, the method first checks if
         * midimessages should be send. If the check
         * returns true, all available IMidiMessable
         * objects are retrieved and their 
         * checkMidiMessage() method is invoked.
         */
        private void checkMidiMessages() {
            if(getGlobalMidiOnOff()) {
                IMidiMessable[] messables = getMidi();
                if(messables != null) {
                    for(int i=0; i<messables.length; i++) {
                    	messables[i].checkMidiMessage();
                    }
                }
            }
        }
        
	}
}
